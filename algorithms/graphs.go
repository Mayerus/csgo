package graphs

//func BFS[T Numeric](node *TreeNode[T], start int) {
//	//if g.value is goal:
//	//	return 0
//	q := &Queue[*TreeNode[T]]{}
//	q.Push(node)
//	return bfs(goal, q, list(), 0)
//}
//
//// (goal: str, q: Queue, visited: list, count: int)
//func bfs[T Numeric](goal string, q *Qeueue[T], visited LinkedList, count int) {
//	g: UndirectedGraph[str] = q.get()
//	visited.append(g)
//	for node in g.neighbors {
//		if node in visited {
//			continue
//		}
//		visited.append(node)
//		if node.value is goal {
//			return count
//		}
//	}
//		q.Push(node)
//	if q.IsEmpty() {
//		return -1
//	}
//	return bfs(goal, q, visited, count+1)
//
//}
